using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Normal.Realtime.Serialization;

/*
 * Rainfall.XRCore.AppearanceModel * 
 * model to contain information about the appearance of the avatar:
 *  - Avatar name
 *  - TODO: model def.
     */

namespace Normal.Realtime
{
    [RealtimeModel]
    public partial class AvatarAppearanceModel
    {
        [RealtimeProperty(1000, true, true)]
        private string _name;

        [RealtimeProperty(1001, true, true)]
        private bool _pointer;
    }
}


/* ----- Begin Normal Autogenerated Code ----- */
namespace Normal.Realtime {
    public partial class AvatarAppearanceModel : IModel {
        // Properties
        public string name {
            get { return _cache.LookForValueInCache(_name, entry => entry.nameSet, entry => entry.name); }
            set { if (value == name) return; _cache.UpdateLocalCache(entry => { entry.nameSet = true; entry.name = value; return entry; }); FireNameDidChange(value); }
        }
        public bool pointer {
            get { return _cache.LookForValueInCache(_pointer, entry => entry.pointerSet, entry => entry.pointer); }
            set { if (value == pointer) return; _cache.UpdateLocalCache(entry => { entry.pointerSet = true; entry.pointer = value; return entry; }); FirePointerDidChange(value); }
        }
        
        // Events
        public delegate void NameDidChange(AvatarAppearanceModel model, string value);
        public event         NameDidChange nameDidChange;
        public delegate void PointerDidChange(AvatarAppearanceModel model, bool value);
        public event         PointerDidChange pointerDidChange;
        
        // Delta updates
        private struct LocalCacheEntry {
            public bool   nameSet;
            public string name;
            public bool   pointerSet;
            public bool   pointer;
        }
        
        private LocalChangeCache<LocalCacheEntry> _cache;
        
        public AvatarAppearanceModel() {
            _cache = new LocalChangeCache<LocalCacheEntry>();
        }
        
        // Events
        public void FireNameDidChange(string value) {
            try {
                if (nameDidChange != null)
                    nameDidChange(this, value);
            } catch (System.Exception exception) {
                Debug.LogException(exception);
            }
        }
        public void FirePointerDidChange(bool value) {
            try {
                if (pointerDidChange != null)
                    pointerDidChange(this, value);
            } catch (System.Exception exception) {
                Debug.LogException(exception);
            }
        }
        
        // Serialization
        enum PropertyID {
            Name = 1000,
            Pointer = 1001,
        }
        
        public int WriteLength(StreamContext context) {
            int length = 0;
            
            if (context.fullModel) {
                // Mark unreliable properties as clean and flatten the in-flight cache.
                // TODO: Move this out of WriteLength() once we have a prepareToWrite method.
                _name = name;
                _pointer = pointer;
                _cache.Clear();
                
                // Write all properties
                length += WriteStream.WriteStringLength((uint)PropertyID.Name, _name);
                length += WriteStream.WriteVarint32Length((uint)PropertyID.Pointer, _pointer ? 1u : 0u);
            } else {
                // Reliable properties
                if (context.reliableChannel) {
                    LocalCacheEntry entry = _cache.localCache;
                    if (entry.nameSet)
                        length += WriteStream.WriteStringLength((uint)PropertyID.Name, entry.name);
                    if (entry.pointerSet)
                        length += WriteStream.WriteVarint32Length((uint)PropertyID.Pointer, entry.pointer ? 1u : 0u);
                }
            }
            
            return length;
        }
        
        public void Write(WriteStream stream, StreamContext context) {
            if (context.fullModel) {
                // Write all properties
                stream.WriteString((uint)PropertyID.Name, _name);
                stream.WriteVarint32((uint)PropertyID.Pointer, _pointer ? 1u : 0u);
            } else {
                // Reliable properties
                if (context.reliableChannel) {
                    LocalCacheEntry entry = _cache.localCache;
                    if (entry.nameSet || entry.pointerSet)
                        _cache.PushLocalCacheToInflight(context.updateID);
                    
                    if (entry.nameSet)
                        stream.WriteString((uint)PropertyID.Name, entry.name);
                    if (entry.pointerSet)
                        stream.WriteVarint32((uint)PropertyID.Pointer, entry.pointer ? 1u : 0u);
                }
            }
        }
        
        public void Read(ReadStream stream, StreamContext context) {
            bool nameExistsInChangeCache = _cache.ValueExistsInCache(entry => entry.nameSet);
            bool pointerExistsInChangeCache = _cache.ValueExistsInCache(entry => entry.pointerSet);
            
            // Remove from in-flight
            if (context.deltaUpdatesOnly && context.reliableChannel)
                _cache.RemoveUpdateFromInflight(context.updateID);
            
            // Loop through each property and deserialize
            uint propertyID;
            while (stream.ReadNextPropertyID(out propertyID)) {
                switch (propertyID) {
                    case (uint)PropertyID.Name: {
                        string previousValue = _name;
                        
                        _name = stream.ReadString();
                        
                        if (!nameExistsInChangeCache && _name != previousValue)
                            FireNameDidChange(_name);
                        break;
                    }
                    case (uint)PropertyID.Pointer: {
                        bool previousValue = _pointer;
                        
                        _pointer = (stream.ReadVarint32() != 0);
                        
                        if (!pointerExistsInChangeCache && _pointer != previousValue)
                            FirePointerDidChange(_pointer);
                        break;
                    }
                    default:
                        stream.SkipProperty();
                        break;
                }
            }
        }
    }
}
/* ----- End Normal Autogenerated Code ----- */
